#summary A comprehensive introduction to using the Java regexml library.

This page is under construction.

= Project Description =

The regexml Java library provides a way to define regular expressions in a verbose XML vocabulary rather than the terse and cryptic format currently in use. By defining and documenting complex expressions in XML, regular expressions are easier to understand, debug, and maintain.

= Library Installation =

In order to use the regexml Java library, simply add the _regexml-x.x.x.jar_ file to your project's classpath. Once added, four public classes and one interface will be available to your application. Each of these classes and the interface are described in detail in the following section.

= Java API =

The regexml library API is very simple. There are only four classes and one interface to learn as shown here:

|| *Class / Interface* || *Description* ||
|| `Resource` || Interface implemented by classes that encapsulate a regexml expressions file (`ClassPathResource` and `FileSystemResource`). ||
|| `ClassPathResource` || Represents an XML file available on the classpath that contains regexml expressions (implements the `Resource` interface). ||
|| `FileSystemResource` || Represents an XML file available on the file system that contains regexml expressions (implements the `Resource` interface). ||
|| `Expression` || Provides access to a regexml expression's `java.util.regex.Pattern` object and a text representation of the expression in standard regular expression syntax. ||
|| `ExpressionFactory` || Parses the XML file represented by a `ClassPathResource` or `FileSystemResource` object and creates a `java.util.regex.Pattern` object for each expression defined in the XML. The `Pattern` object can then be used to extract portions of a string or match text against the pattern. ||

Now let's take a look at each of these classes and interface.

== Resource Interface and Classes ==

The `Resource` interface represents an object through which a regexml expressions file can be accessed. The `ClassPathResource` and `FileSystemResource` classes implement `Resource` and are used to access a regexml expressions file via the classpath or file system, respectively. `ClassPathResource` is instantiated like this:

{{{
Resource cpResource = new ClassPathResource("expressions.xml");
}}}

`FileSystemResource` is instantiated like this:

{{{
Resource fsResource = new FileSystemResource("/home/user/expressions.xml");
}}}

Or like this:

{{{
File file = new File("/home/user/expressions.xml");
Resource fsResource = new FileSystemResource(file);
}}}

Depending on the type of resource file you choose, the regexml expressions file can be accessed from either the classpath or the file system. Keep in mind that after an application is packaged for distribution, it's usually easier to access the expressions file from the classpath rather than the file system.

== Expression Class ==

The `Expression` class encapsulates information related to a single regexml expression. This class exposes the following public methods:

|| *Method* || *Description* ||
|| `getId()` || Gets the ID for this expression as specified in the regexml expressions file. ||
|| `getPattern()` || Gets the `java.util.regex.Pattern` object associated with this expression. ||
|| `getRegExString()` || Gets a text representation of the expression in traditional regular expression syntax. ||

Typically, you will only be interested in retrieving `Pattern` objects in order to evaluate regular expressions. In that case, the `ExpressionFactory` class provides a convenience method called `getPattern()` that allows you to bypass the `Expression` object and retrieve the `Pattern` object directly. Regardless, the `Expression` object is available for times when you need to access the expression's ID or see the expression in traditional regular expression syntax.

== ExpressionFactory Class ==

The `ExpressionFactory` class compiles regexml expressions into standard `java.util.regex.Pattern` objects and makes them available to client applications via the `getExpression()` and `getPattern()` methods. `ExpressionFactory` can be instantiated like this:

{{{
ExpressionFactory expressionFactory = new ExpressionFactory(new ClassPathResource("expressions.xml"));
}}}

`ExpressionFactory` exposes the following public methods:

|| *Method* || *Description* ||
|| `getExpression(String id)` || Gets the `Expression` object associated with the given expression ID. ||
|| `getPattern(String id)` || Gets the `java.util.regex.Pattern` object associated with the given expression ID. ||

Once the `ExpressionFactory` is instantiated, it can be used to evaluate regexml expressions. For example, given this regexml expressions file:

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="phone">
        <start/>
        <match equals="("/>
        <match equals="\d" min="3"/> <!-- area code -->
        <match equals=") "/>
        <match equals="\d" min="3"/> <!-- prefix -->
        <match equals="-"/>
        <match equals="\d" min="4"/>
        <end/>
    </expression>
</regexml>
}}}

We can validate a phone number with the following Java code:

{{{
Expression expr = expressionFactory.getExpression("phone");

java.util.regex.Pattern pattern = expr.getPattern();
java.util.regex.Matcher matcher = pattern.matcher("(801) 555-1212");

if (matcher.matches())
{
    System.out.println("Thanks for the valid phone number!");
}
else
{
    System.out.println("This phone number is invalid! Please use this format: (XXX) XXX-XXXX");
}

System.out.println("Expression in regular expression syntax: " + expr.getRegExString());
}}}

The code above retrieves an `Expression` object because it's needed in order to output the expression in regular expression syntax. If all we want to do is validate a phone number, we can bypass the `Expression` object and retrieve the `java.util.regex.Pattern` object directly like this:

{{{
java.util.regex.Pattern pattern = expressionFactory.getPattern("phone");
java.util.regex.Matcher matcher = pattern.matcher("(801) 555-1212");

if (matcher.matches())
{
    System.out.println("Thanks for the valid phone number!");
}
else
{
    System.out.println("This phone number is invalid! Please use this format: (XXX) XXX-XXXX");
}
}}}

In addition to validating a phone number, we can also extract information from it by adding `capture` attributes to the regexml expression like this:

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="phone">
        <start/>
        <match equals="("/>
        <match equals="\d" min="3" capture="true"/> <!-- area code -->
        <match equals=") "/>
        <match equals="\d" min="3" capture="true"/> <!-- prefix -->
        <match equals="-"/>
        <match equals="\d" min="4"/>
        <end/>
    </expression>
</regexml>
}}}

The expression above will allow us to extract the area code and prefix from any valid phone number. The Java code looks like this:

{{{
java.util.regex.Pattern pattern = expressionFactory.getPattern("phone");
java.util.regex.Matcher matcher = pattern.matcher("(801) 555-1212");

if (matcher.find())
{
    for (int i = 1; i <= matcher.groupCount(); i++) //iterate through all captured matches
    {
        System.out.println(matcher.group(i));
    }
}
}}}

The output from this program looks like this:

 `801`<br>
 `555`

The `Matcher` object creates a group for each `<match/>` element whose `capture` attribute is set. For more information on using the Java `Pattern` and `Matcher` classes, see the javadocs here:

[http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html]<br>
[http://java.sun.com/javase/6/docs/api/java/util/regex/Matcher.html]

= Expressions File =

The expressions file is the heart of the regexml library. It is in this file that regular expressions are defined in a simple XML format. Only one expressions file is needed per application since a single file can contain any number of regular expressions.

== Create the File ==

In order to simplify creation of the regexml expressions file, a schema is provided that describes the structure of a valid file. In order to retrieve the XML schema, you'll need to open the regexml JAR in a compression utility (e.g., WinZip, jZip, StuffIt, Zipeg, etc.) or the Java command-line _jar_ utility and extract the file named _regexml.xsd_. Using the _jar_ utility that ships with Java, you can extract the schema with this command:

 `jar -xf regexml-x.x.x.jar regexml.xsd`

Once the schema is available in the file system, you can reference it from any XML editor that supports schemas by associating it with the following namespace:

 `http://schemas.regexml.org/expressions`

For example, in IntelliJ IDEA (my IDE of choice), bring up the "Settings" dialog box and select "Resources". Then click the "Add..." button in the "Configure External Resources" section and enter a URI of `http://schemas.regexml.org/expressions` as well as the path to the schema file under Location. Once the regexml namespace is associated with the schema, IDEA will assist you when creating regexml expression files by showing the valid elements and attributes available at any point in the document. Just be sure to use a _.xml_ file extension and include the regexml expressions namespace at the beginning of the file like this:

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
</regexml>
}}}

Other schema-aware XML editors should have similar ways to associate a namespace with a schema file. The structure of the expressions file is discussed in detail in the following sections.

== File Format ==

The format of the regexml expressions file is defined by an XML schema. The following table documents the elements and attributes declared in this schema.

|| *Element* || *Attribute* || *Default Value* || *Description* ||
|| regexml || || || Root element. Contains any number of expression elements. ||
|| || autoEscape || true || Causes regexml to automatically escape most special regular expression characters. ||
|| expression || || || Defines a single regular expression. Contains any number of match and/or group elements. ||
|| || id || || Unique identifier for the expression. ||
|| || ignoreCase || false || Indicates whether or not case should be ignored when performing text comparisons. ||
|| || dotMatchesLineBreaks || false || Indicates whether or not the dot (i.e., period) matches line breaks in addition to all other characters. ||
|| || anchorsMatchLineBreaks || false || Indicates whether or not the `<start/>` and `<end/>` anchors match line breaks. ||
|| match || || || Specifies criteria to match one part of the text. The equals and except attributes are mutually exclusive. If both are specified, one will be ignored. ||
|| || equals || || Matching expression (cannot be used with the except attribute). ||
|| || except || || Negated matching expression (cannot be used with the equals attribute). ||
|| || min || 1 || Minimum number of times the match may be repeated. ||
|| || max || 1 || Maximum number of times the match may be repeated. ||
|| || capture || false || Indicates whether or not the matching text should be extracted and made available to the application. ||
|| || ignoreCase || false || Indicates whether or not case should be ignored when performing text comparisons. ||
|| || dotMatchesLineBreaks || false || Indicates whether or not the dot (i.e., period) matches line breaks in addition to all other characters. ||
|| group || || || Associates multiple matches into a logical group. Contains any number of match and/or group elements. ||
|| || operator || and || Indicates whether an "and" or an "or" operation should be applied to matches within the group. ||
|| || min || 1 || Minimum number of times the group may be repeated. ||
|| || max || 1 || Maximum number of times the group may be repeated. ||
|| || capture || false || Indicates whether or not the text from the matching group should be extracted and made available to the application. ||
|| || ignoreCase || false || Indicates whether or not case should be ignored when performing text comparisons. ||
|| || dotMatchesLineBreaks || false || Indicates whether or not the dot (i.e., period) matches line breaks in addition to all other characters. ||
|| start || || || Anchors the match to the beginning of the text (must start at the beginning of the text or line). ||
|| || matchLineBreaks || false || Indicates whether or not this anchor should match line breaks. ||
|| end || || || Anchors the match to the end of the text (must end at the end of the text or line). ||
|| || matchLineBreaks || false || Indicates whether or not this anchor should match line breaks. ||

For additional file format information, see the _regexml.xsd_ schema included in the regexml JAR file.

== Expression Examples ==

The following sections provide examples of various regexml expressions.

=== Empty File ===

The simplest valid expressions file is a file that defines no expressions like this:

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
</regexml>
}}}

Even though it doesn't define any expressions, this file still satisfies the schema because it uses the `<regexml>` root element and the correct regexml expressions namespace.

=== Literal Match ===


About the simplest expressions file that may be useful is one that includes a single expression that performs a literal match.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letter">
        <match equals="a"/>
    </expression>
</regexml>
}}}

Matches: a<br>
Regular expression: a

=== Multiple Matches ===

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a"/>
        <match equals="b"/>
    </expression>
</regexml>
}}}

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="ab"/>
    </expression>
</regexml>
}}}

=== Optional Match ===

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letter">
        <match equals="a"/>
        <match equals="b" min="0"/>
    </expression>
</regexml>
}}}

Matches: a, ab

=== Exact Quantity Match ===

Whenever the `max` attribute is less than the `min` attribute, `max` is automatically set equal to `min`. This behavior allows an exact number of matches to be specified by setting only the `min` attribute (since `max` defaults to 1, any `min` amount greater than 1 will cause `max` to be assigned the same value).

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a" min="3"/>
    </expression>
</regexml>
}}}

Matches: aaa

=== Maximum Quantity Match ===

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a" max="3"/>
    </expression>
</regexml>
}}}

Matches: a, aa, aaa

=== Quantity Range Match ===

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a" min="2" max="4"/>
    </expression>
</regexml>
}}}

Matches: aa, aaa, aaaa<br>
Regular expression: 

=== Matching Constructs ===

|| *Construct* || *Matches* ||
|| _x_ || Any literal character _x_ except for period, backslash, less than symbol, and double quotes. [`.\<"`] ||
|| `\.` || Period character ||
|| `\\` || Backslash character ||
|| `&lt;` || Less than character (since it conflicts with XML markup) ||
|| `&quot;` || Double quote character `"` (escape not needed when using single-quotes to delimit attribute values) ||
|| `&apos;` || Single quote character `'` (escape not needed when using double-quotes to delimit attribute values) ||
|| `.` || Any character (matches line terminators only if the dotMatchAll attribute is set to true) ||
|| `\d` || Digit [`0-9`] ||
|| `\D` || Non-digit ||
|| `\s` || Whitespace characters including space, tab, new line, form-feed, and carriage return [` \t\n\f\r`] ||
|| `\S` || Non-whitespace character ||
|| `\w` || Word character [`a-zA-Z_0-9`] ||
|| `\W` || Non-word character ||
|| `\b` || Word boundary anchor (e.g., `\bJava\b` matches "Java" but not "JavaScript". Finds whole words only.) ||
|| `\B` || Non-word boundary anchor || 
|| `[ab\d]` || Character class matching a, b, or any digit ||
|| `[0-9a-f]` || Ranges matching digits 0 through 9 and letters a through f (hyphen indicates a range) ||
|| `[a\-c]` || Characters a, c, and hyphen (within character classes, literal hyphens must be escaped) ||

More about constructs here...