#summary A comprehensive introduction to using the Java regexml library.

= Project Description =

The regexml Java library provides a way to define regular expressions in a verbose XML vocabulary rather than the terse and cryptic format currently in use. By defining and documenting complex expressions in XML, regular expressions are easier to understand, debug, and maintain.

= Library Installation =

In order to use the regexml Java library, simply add the _regexml-x.x.x.jar_ file to your project's classpath. Once added, four public classes and one interface will be available to your application. Each of these classes and the interface are described in detail in the following section.

= Java API =

The regexml library API is very simple. There are only four classes and one interface to learn as shown here:

|| *Class / Interface* || *Description* ||
|| `Resource` || Interface implemented by classes that encapsulate a regexml expressions file (`ClassPathResource` and `FileSystemResource`). ||
|| `ClassPathResource` || Represents an XML file available on the classpath that contains regexml expressions (implements the `Resource` interface). ||
|| `FileSystemResource` || Represents an XML file available on the file system that contains regexml expressions (implements the `Resource` interface). ||
|| `Expression` || Provides access to a regexml expression's `java.util.regex.Pattern` object and a text representation of the expression in standard regular expression syntax. ||
|| `ExpressionFactory` || Parses the XML file represented by a `ClassPathResource` or `FileSystemResource` object and creates a `java.util.regex.Pattern` object for each expression defined in the XML. The `Pattern` object can then be used to extract portions of a string or match text against the pattern. ||

The javadoc is available [http://regexml.googlecode.com/svn/trunk/javadoc/index.html here]. Now let's take a look at each of these classes and interface.

== Resource Interface and Classes ==

The `Resource` interface represents an object through which a regexml expressions file can be accessed. The `ClassPathResource` and `FileSystemResource` classes implement `Resource` and are used to access a regexml expressions file via the classpath or file system, respectively. `ClassPathResource` is instantiated like this:

{{{
Resource cpResource = new ClassPathResource("expressions.xml");
}}}

`FileSystemResource` is instantiated like this:

{{{
Resource fsResource = new FileSystemResource("/home/user/expressions.xml");
}}}

Or like this:

{{{
File file = new File("/home/user/expressions.xml");
Resource fsResource = new FileSystemResource(file);
}}}

Depending on the type of resource file you choose, the regexml expressions file can be accessed from either the classpath or the file system. Keep in mind that after an application is packaged for distribution, it's usually easier to access the expressions file from the classpath rather than the file system.

== Expression Class ==

The `Expression` class encapsulates information related to a single regexml expression. This class exposes the following public methods:

|| *Method* || *Description* ||
|| `getId()` || Gets the ID for this expression as specified in the regexml expressions file. ||
|| `getPattern()` || Gets the `java.util.regex.Pattern` object associated with this expression. ||
|| `getRegExString()` || Gets a text representation of the expression in traditional regular expression syntax. ||

Typically, you will only be interested in retrieving `Pattern` objects in order to evaluate regular expressions. In that case, the `ExpressionFactory` class provides a convenience method called `getPattern()` that allows you to bypass the `Expression` object and retrieve the `Pattern` object directly. Regardless, the `Expression` object is available for times when you need to access the expression's ID or see the expression in traditional regular expression syntax.

== ExpressionFactory Class ==

The `ExpressionFactory` class compiles regexml expressions into standard `java.util.regex.Pattern` objects and makes them available to client applications via the `getExpression()` and `getPattern()` methods. `ExpressionFactory` can be instantiated like this:

{{{
ExpressionFactory expressionFactory = new ExpressionFactory(new ClassPathResource("expressions.xml"));
}}}

`ExpressionFactory` exposes the following public methods:

|| *Method* || *Description* ||
|| `getExpression(String id)` || Gets the `Expression` object associated with the given expression ID. ||
|| `getPattern(String id)` || Gets the `java.util.regex.Pattern` object associated with the given expression ID. ||

Once the `ExpressionFactory` is instantiated, it can be used to evaluate regexml expressions. For example, given this regexml expressions file:

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="phone">
        <start/>
        <match equals="("/>
        <match equals="\d" min="3"/> <!-- area code -->
        <match equals=") "/>
        <match equals="\d" min="3"/> <!-- prefix -->
        <match equals="-"/>
        <match equals="\d" min="4"/>
        <end/>
    </expression>
</regexml>
}}}

We can validate a phone number with the following Java code:

{{{
Expression expr = expressionFactory.getExpression("phone");

java.util.regex.Pattern pattern = expr.getPattern();
java.util.regex.Matcher matcher = pattern.matcher("(801) 555-1212");

if (matcher.matches())
{
    System.out.println("Thanks for the valid phone number!");
}
else
{
    System.out.println("This phone number is invalid! Please use this format: (XXX) XXX-XXXX");
}

System.out.println("Expression in regular expression syntax: " + expr.getRegExString());
}}}

The code above retrieves an `Expression` object because it's needed in order to output the expression in regular expression syntax. If all we want to do is validate a phone number, we can bypass the `Expression` object and retrieve the `java.util.regex.Pattern` object directly like this:

{{{
java.util.regex.Pattern pattern = expressionFactory.getPattern("phone");
java.util.regex.Matcher matcher = pattern.matcher("(801) 555-1212");

if (matcher.matches())
{
    System.out.println("Thanks for the valid phone number!");
}
else
{
    System.out.println("This phone number is invalid! Please use this format: (XXX) XXX-XXXX");
}
}}}

In addition to validating a phone number, we can also extract information from it by adding `capture` attributes to the regexml expression like this:

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="phone">
        <start/>
        <match equals="("/>
        <match equals="\d" min="3" capture="true"/> <!-- area code -->
        <match equals=") "/>
        <match equals="\d" min="3" capture="true"/> <!-- prefix -->
        <match equals="-"/>
        <match equals="\d" min="4"/>
        <end/>
    </expression>
</regexml>
}}}

The expression above will allow us to extract the area code and prefix from any valid phone number. The Java code looks like this:

{{{
java.util.regex.Pattern pattern = expressionFactory.getPattern("phone");
java.util.regex.Matcher matcher = pattern.matcher("(801) 555-1212");

if (matcher.find())
{
    for (int i = 1; i <= matcher.groupCount(); i++) //iterate through all captured matches
    {
        System.out.println(matcher.group(i));
    }
}
}}}

The output from this program looks like this:

 `801`<br>
 `555`

The `Matcher` object creates a group for each `<match/>` element whose `capture` attribute is set. For more information on using the Java `Pattern` and `Matcher` classes, see the javadocs here:

[http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html]<br>
[http://java.sun.com/javase/6/docs/api/java/util/regex/Matcher.html]

For more details on the regexml classes, see the [http://regexml.googlecode.com/svn/trunk/javadoc/index.html regexml javadoc].

= Expressions File =

The expressions file is the heart of the regexml library. It is in this file that regular expressions are defined in a simple XML format. Only one expressions file is needed per application since a single file can contain any number of regular expressions.

== Create the File ==

In order to simplify creation of the regexml expressions file, a schema is provided that describes the structure of a valid file. In order to retrieve the XML schema, you'll need to open the regexml JAR in a compression utility (e.g., WinZip, jZip, StuffIt, Zipeg, etc.) or the Java command-line _jar_ utility and extract the file named _regexml.xsd_. Using the _jar_ utility that ships with Java, you can extract the schema with this command:

 `jar -xf regexml-x.x.x.jar regexml.xsd`

Once the schema is available in the file system, you can reference it from any XML editor that supports schemas by associating it with the following namespace:

 `http://schemas.regexml.org/expressions`

For example, in IntelliJ IDEA (my IDE of choice), bring up the "Settings" dialog box and select "Resources". Then click the "Add..." button in the "Configure External Resources" section and enter a URI of `http://schemas.regexml.org/expressions` as well as the path to the schema file under Location. Once the regexml namespace is associated with the schema, IDEA will assist you when creating regexml expression files by showing the valid elements and attributes available at any point in the document. Just be sure to use a _.xml_ file extension and include the regexml expressions namespace at the beginning of the file like this:

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
</regexml>
}}}

Other schema-aware XML editors should have similar ways to associate a namespace with a schema file. The structure of the expressions file is discussed in detail in the following sections.

== File Format ==

Detailed documentation regarding the regexml expressions file format is available [ExpressionsFileFormat here].

== Expression Examples ==

The following sections provide examples of various regexml expressions.

=== Empty File ===

The simplest valid expressions file is a file that defines no expressions like this:

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
</regexml>
}}}

Even though it doesn't define any expressions, this file still satisfies the schema because it uses the `<regexml>` root element and the correct regexml expressions namespace.

=== Literal Match ===

About the simplest expressions file that may be useful is one that includes a single expression that performs a literal match.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letter">
        <match equals="a"/>
    </expression>
</regexml>
}}}

Matches: _a_<br>
Regular expression: `a`

=== Multiple Matches ===

Since matches are automatically concatenated (unless included in an "or" group discussed later), the following two regexml expressions are equivalent.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a"/>
        <match equals="b"/>
    </expression>
</regexml>
}}}

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="ab"/>
    </expression>
</regexml>
}}}

Matches: _ab_<br>
Regular expression: `ab`

=== Optional Match ===

A match can be made optional by setting it's `min` attribute to zero (`min` defaults to one). For example, the `a` in the following regexml expression is required for a match but the `b` is optional.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a"/>
        <match equals="b" min="0"/>
    </expression>
</regexml>
}}}

Matches: _a_, _ab_<br>
Regular expression: `ab?`

=== Exact Quantity Match ===

Whenever the `max` attribute is less than the `min` attribute, `max` is automatically set equal to `min`. This behavior allows an exact number of matches to be specified by setting only the `min` attribute (since `max` defaults to one, any `min` amount greater than one will cause `max` to be assigned the same value).

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a" min="3"/>
    </expression>
</regexml>
}}}

Matches: _aaa_<br>
Regular expression: `a{3}`

=== Maximum Quantity Match ===

If only a `max` value is set, the default `min` value of one will be used.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a" max="3"/>
    </expression>
</regexml>
}}}

Matches: _a_, _aa_, _aaa_<br>
Regular expression: `a{1,3}`

=== Quantity Range Match ===

Setting the `min` and `max` attributes allows a quantity range to be specified.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a" min="2" max="4"/>
    </expression>
</regexml>
}}}

Matches: _aa_, _aaa_, _aaaa_<br>
Regular expression: `a{2,4}`

=== Unbounded Quantity Range Match ===

Typically, the `min` and `max` attributes will be set to non-negative integer values. However, to support unbounded maximum values, the value of the `max` attribute can be set to an asterisk (`*`). This indicates an infinite number.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a" min="2" max="*"/>
    </expression>
</regexml>
}}}

Matches: _aa_, _aaa_, _aaaa_, ...<br>
Regular expression: `a{2,}`

=== Group Quantity Match ===

The `min` and `max` quantity attributes work with groups the same as they do with individual matches.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <group>
            <match equals="a"/>            
        </group>
        <group min="0">
            <match equals="b"/>
            <match equals="c"/>
        </group>
        <group max="2">
            <match equals="d"/>
        </group>
    </expression>
</regexml>
}}}

Matches: _ad_, _add_, _abcd_, _abcdd_<br>
Regular expression: `(?:a)(?:bc)?(?:d){1,2}`

=== Character Class Match ===

A _character class_ defines a set of characters enclosed in brackets that are used to match text. If no quantity modifiers are specified (i.e., `min` and `max` attributes), a character class matches a single character. For example, the character class `[abc]` matches a single character _a_, _b_, or _c_. Applying quantity modifiers allows any number of characters to be matched.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="[abc]" max="2"/>
    </expression>
</regexml>
}}}

Matches: _a_, _b_, _c_, _aa_, _ab_, _ac_, _ba_, _bb_, _bc_, _ca_, _cb_, _cc_<br>
Regular expression: `[abc]{1,2}`

=== Character Class Range Match ===

The hyphen character is used to represent a range of characters within a character class. For example, the character class `[a-z]` represents all lowercase letters. Since it has special meaning, the hyphen must be escaped within character classes if wished to be used literally. For example, the character class `[a\-z]` represents the characters _a_, _-_, and _z_ rather than a range of letters from _a_ to _z_.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="[a-c1-3]"/>
    </expression>
</regexml>
}}}

Matches: _a_, _b_, _c_, _1_, _2_, _3_<br>
Regular expression: `[a-c1-3]`

Characters can be removed from a range by subtracting them using the hyphen character at the end of the range like this:

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="[a-z-[d-w]]"/>
    </expression>
</regexml>
}}}

Matches: _a_, _b_, _c_, _x_, _y_, _z_<br>
Regular expression: `[a-z-[d-w]]`

=== Predefined Character Class Matches ===

For convenience, regular expressions offer a few predefined character classes. The following predefined character classes are available:

|| *Characters* || *Description* ||
|| `.` || Any character ||
|| `\d` || Digit `[0-9]` ||
|| `\D` || Non-digit `[^0-9]` ||
|| `\s` || Whitespace character `[ \t\n\f\r]` ||
|| `\S` || Non-whitespace character `[^ \t\n\f\r]` ||
|| `\w` || Word character `[a-zA-Z_0-9]` ||
|| `\W` || Non-word character `[^a-zA-Z_0-9]` ||
|| `\b` || Word boundary (break between words) ||
|| `\B` || Non-word boundary ||

As shown in the table above, the predefined character class `\d` is equivalent to the user-defined character class `[0-9]`. Often times regexml expressions can be simplified through the use of these predefined character classes.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="."/>
        <match equals="\d" min="3"/>
        <match equals="\s"/>
        <match equals="\w" min="3"/>
    </expression>
</regexml>
}}}

Matches: any character followed by three digits followed by one whitespace character followed by three word characters<br>
Regular expression: `\d{3}\s\w{3}`

=== Negated Match ===

The `except` attribute is the opposite of the match element's `equals` attribute. It basically negates the expression.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="\d"/>
        <match except="\d"/>
    </expression>
</regexml>
}}}

Matches: one digit followed by one non-digit character<br>
Regular expression: `\d[^\d]`

=== Look-ahead and Look-behind ===

Look-aheads and look-behinds (positive and negative) are not yet supported in regexml.

=== Matching Constructs ===

|| *Construct* || *Matches* ||
|| _x_ || Any literal character _x_ except for period, backslash, less than symbol, and double quotes. [`.\<"`] ||
|| `\.` || Period character ||
|| `\\` || Backslash character ||
|| `&lt;` || Less than character (since it conflicts with XML markup) ||
|| `&quot;` || Double quote character `"` (escape not needed when using single-quotes to delimit attribute values) ||
|| `&apos;` || Single quote character `'` (escape not needed when using double-quotes to delimit attribute values) ||
|| `.` || Any character (matches line terminators only if the dotMatchAll attribute is set to true) ||
|| `\d` || Digit [`0-9`] ||
|| `\D` || Non-digit ||
|| `\s` || Whitespace characters including space, tab, new line, form-feed, and carriage return [` \t\n\f\r`] ||
|| `\S` || Non-whitespace character ||
|| `\w` || Word character [`a-zA-Z_0-9`] ||
|| `\W` || Non-word character ||
|| `\b` || Word boundary anchor (e.g., `\bJava\b` matches "Java" but not "JavaScript". Finds whole words only.) ||
|| `\B` || Non-word boundary anchor || 
|| `[ab\d]` || Character class matching a, b, or any digit ||
|| `[0-9a-f]` || Digits 0 through 9 and letters a through f (hyphen indicates a range) ||
|| `[a\-c]` || Characters a, c, and hyphen (within character classes, literal hyphens must be escaped) ||

More about constructs here...