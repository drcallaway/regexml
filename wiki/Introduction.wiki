#summary A comprehensive introduction to using the Java regexml library.

This page is under construction.

= Project Description =

The regexml Java library provides a way to define regular expressions in verbose XML rather than the terse and cryptic format currently in use. By defining and documenting complex expressions in XML, regular expressions are easier to understand, debug, and maintain.

= Library Installation =

In order to use the regexml Java library, simply add the _regexml-x.x.x.jar_ file to your project's classpath. Once added, the following public classes will be available to your application:

|| *Class* || *Description* ||
|| ClassPathResource || Specifies the name of an XML file available on the classpath that contains regexml expressions. ||
|| FileSystemResource || Specifies the name of an XML file available on the file system that contains regexml expressions. ||
|| ExpressionFactory || Parses the XML file specified by a `ClassPathResource` or `FileSystemResource` object and creates a `java.util.regex.Pattern` object for each expression defined in the XML. The `Pattern` object can then be used to extract portions of a string or match text against the pattern. ||
|| Expression || Provides access to a regexml expression's `java.util.regex.Pattern` object as well as the standard regular expression string represented by the expression. ||

The next section demonstrates how these classes are used.

= Java API =

Within your application, you can choose to access the regexml expressions file from either the classpath or the file system (depending on whether you choose to pass a `ClassPathResource` or `FileSystemResource` object when instantiating the `ExpressionFactory` class). Keep in mind that after an application is packaged for distribution, it's usually easier to access the expressions file from the classpath rather than the file system.

= Expressions File =

The expressions file is the heart of the regexml library. It is within this file that regular expressions are defined in a simple XML format. Only one expressions file is needed per application since a single file can contain any number of regular expressions.

== Create the File ==

After adding the regexml JAR to your project, the next step is to create an XML file in which regular expressions are defined. In order to simplify creation of this XML, a schema is provided that describes the structure of a valid file. In order to retrieve the XML schema, you'll need to open the regexml JAR in a compression utility (e.g., WinZip, jZip, StuffIt, Zipeg, etc.) or the Java command-line _jar_ utility and extract the file named _regexml.xsd_. Using the _jar_ utility that ships with Java, you can extract the schema with this command:

 `jar -xf regexml-x.x.x.jar regexml.xsd`

Once the schema is available in the file system, you can reference it from any XML editor that supports schemas by associating it with the following namespace:

 `http://schemas.regexml.org/expressions`

For example, in IntelliJ IDEA (my IDE of choice), bring up the "Settings" dialog box and select "Resources". Then click the "Add..." button in the "Configure External Resources" section and enter a URI of `http://schemas.regexml.org/expressions` as well as the path to the schema file under Location. Once the regexml namespace is associated with the schema, IDEA will assist you when creating regexml expression files by showing the valid elements and attributes available at any point in the document. Just be sure to use a _.xml_ file extension and include the regexml expressions namespace at the beginning of the file like this:

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
</regexml>
}}}

Other schema-aware XML editors should have similar ways to associate a namespace with a schema file. The structure of the expressions file is discussed in detail in the following section.

== File Format ==

The regexml expressions file format is very simple. This section presents the structure of this file in detail.

=== Elements and Attributes ===

|| *Element* || *Attribute* || *Default Value* || *Description* ||
|| regexml || || || Root element. Contains any number of expression elements. ||
|| || autoEscape || true || Causes regexml to automatically escape most special regular expression characters. ||
|| expression || || || Defines a single regular expression. Contains one or more match and/or group elements. ||
|| || id || || Unique identifier for the expression. ||
|| || ignoreCase || false || Indicates whether or not case should be ignored when performing text comparisons. ||
|| || dotMatchesLineBreaks || false || Indicates whether or not the dot (i.e., period) matches line breaks in addition to all other characters. ||
|| || anchorsMatchLineBreaks || false || Indicates whether or not the `<start/>` and `<end/>` anchors match line breaks. ||
|| match || || || Specifies criteria to match one part of the text. The equals and except attributes are mutually exclusive. If both are specified, one will be ignored. ||
|| || equals || || Matching expression (cannot be used with the except attribute). ||
|| || except || || Negated matching expression (cannot be used with the equals attribute). ||
|| || min || 1 || Minimum number of times the match may be repeated. ||
|| || max || 1 || Maximum number of times the match may be repeated. ||
|| || capture || false || Indicates whether or not the matching text should be extracted and made available to the application. ||
|| || ignoreCase || false || Indicates whether or not case should be ignored when performing text comparisons. ||
|| || dotMatchesLineBreaks || false || Indicates whether or not the dot (i.e., period) matches line breaks in addition to all other characters. ||
|| group || || || Associates multiple matches into a logical group. Contains one or more match and/or group elements. ||
|| || operator || and || Indicates whether an "and" or an "or" operation should be applied to matches within the group. ||
|| || min || 1 || Minimum number of times the group may be repeated. ||
|| || max || 1 || Maximum number of times the group may be repeated. ||
|| || capture || false || Indicates whether or not the matching text should be extracted and made available to the application. ||
|| || ignoreCase || false || Indicates whether or not case should be ignored when performing text comparisons. ||
|| || dotMatchesLineBreaks || false || Indicates whether or not the dot (i.e., period) matches line breaks in addition to all other characters. ||
|| start || || || Anchors the match to beginning of text (must start at the beginning of the text or line). ||
|| || matchLineBreaks || false || Indicates whether or not this anchor should match on line breaks. ||
|| end || || || Anchors the match to end of text (must end at the end of the text or line). ||
|| || matchLineBreaks || false || Indicates whether or not this anchor should match on line breaks. ||

=== Empty File ===

The simplest valid expressions file is an file that defines no expressions like this:

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
</regexml>
}}}

Even though it is pretty much empty, this file still satisfies the schema because it uses the `<regexml>` root element and the correct regexml expressions namespace.

=== Literal Match ===

About the simplest expressions file that may be useful is one that includes a single expression that performs a literal match.

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letter">
        <match equals="a"/>
    </expression>
</regexml>
}}}

Matches: a

Regular expression: a

=== Multiple Matches ===

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a"/>
        <match equals="b"/>
    </expression>
</regexml>
}}}

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="ab"/>
    </expression>
</regexml>
}}}

=== Optional Match ===

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letter">
        <match equals="a"/>
        <match equals="b" min="0"/>
    </expression>
</regexml>
}}}

Matches: a, ab

=== Exact Quantity Match ===

Whenever the `max` attribute is less than the `min` attribute, `max` is automatically set equal to `min`. This behavior allows an exact number of matches to be specified by setting only the `min` attribute (since `max` defaults to 1, any `min` amount greater than 1 will cause `max` to be assigned the same value).

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a" min="3"/>
    </expression>
</regexml>
}}}

Matches: aaa

=== Maximum Quantity Match ===

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="letters">
        <match equals="a" max="3"/>
    </expression>
</regexml>
}}}

Matches: a, aa, aaa

=== Quantity Range Match ===

Matches: DustinDustin, DustinDustinDustin, and DustinDustinDustinDustin

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
    <expression id="myName">
        <match equals="Dustin" min="2" max="4"/>
    </expression>
</regexml>
}}}

=== Matching Constructs ===

|| *Construct* || *Matches* ||
|| _x_ || Any literal character _x_ except for period, backslash, less than symbol, and double quotes. [`.\<"`] ||
|| `\.` || Period character ||
|| `\\` || Backslash character ||
|| `&lt;` || Less than character (since it conflicts with XML markup) ||
|| `&quot;` || Double quote character `"` (escape not needed when using single-quotes to delimit attribute values) ||
|| `&apos;` || Single quote character `'` (escape not needed when using double-quotes to delimit attribute values) ||
|| `.` || Any character (matches line terminators only if the dotMatchAll attribute is set to true) ||
|| `\d` || Digit [`0-9`] ||
|| `\D` || Non-digit ||
|| `\s` || Whitespace characters including space, tab, new line, form-feed, and carriage return [` \t\n\f\r`] ||
|| `\S` || Non-whitespace character ||
|| `\w` || Word character [`a-zA-Z_0-9`] ||
|| `\W` || Non-word character ||
|| `\b` || Word boundary anchor (e.g., `\bJava\b` matches "Java" but not "JavaScript". Finds whole words only.) ||
|| `\B` || Non-word boundary anchor || 
|| `[ab\d]` || Character class matching a, b, or any digit ||
|| `[0-9a-f]` || Ranges matching digits 0 through 9 and letters a through f (hyphen indicates a range) ||
|| `[a\-c]` || Characters a, c, and hyphen (within character classes, literal hyphens must be escaped) ||

More about constructs here...