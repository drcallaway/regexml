#summary A comprehensive introduction to using the Java regexml library.

This page is under construction.

= Project Description =

The regexml Java library provides a way to define regular expressions in verbose XML rather than the terse and cryptic format currently in use. By defining and documenting complex expressions in XML, regular expressions are easier to understand, debug, and maintain.

= Library Installation =

In order to use the regexml Java library, simply add the _regexml-x.x.x.jar_ file to your project's classpath. Once added, the following public classes will be available to your application:

|| *Class* || *Description* ||
|| ClassPathResource || Specifies the name of an XML file available on the classpath that contains regexml expressions. ||
|| FileSystemResource || Specifies the name of an XML file available on the file system that contains regexml expressions. ||
|| ExpressionFactory || Parses the XML file specified by a `ClassPathResource` or `FileSystemResource` object and creates a `java.util.regex.Pattern` object for each expression defined in the XML. The `Pattern` object can then be used to extract portions of a string or match text against the pattern. ||
|| Expression || Provides access to a regexml expression's `java.util.regex.Pattern` object as well as the standard regular expression string represented by the expression. ||

See below for examples of how to use these classes.

= Expressions File =

The expressions file is the heart of the regexml library. It is within this file that regular expressions are defined in a simple XML format. Only one expressions file is needed per application since a single file can contain any number of regular expressions.

== Create the File ==

After adding the regexml JAR to your project, the next step is to create an XML file in which regular expressions are defined. In order to simplify creation of this XML, a schema is provided that describes the structure of a valid file. In order to retrieve the XML schema, you'll need to open the regexml JAR in a compression utility (e.g., WinZip, jZip, StuffIt, Zipeg, etc.) or the Java command-line _jar_ utility and extract the file named _regexml.xsd_. Using the _jar_ utility that ships with Java, you can extract the schema with this command:

 `jar -xf regexml-x.x.x.jar regexml.xsd`

Once the schema is available in the file system, you can reference it from any XML editor that supports schemas by associating it with the following namespace:

 `http://schemas.regexml.org/expressions`

For example, in IntelliJ IDEA (my IDE of choice), bring up the "Settings" dialog box and select "Resources". Then click the "Add..." button in the "Configure External Resources" section and enter a URI of `http://schemas.regexml.org/expressions` as well as the path to the schema file under Location. Once the regexml namespace is associated with the schema, IDEA will assist you when creating regexml expression files by showing the valid elements and attributes available at any point in the document. Just be sure to use a _.xml_ file extension and include the regexml expressions namespace at the beginning of the file like this:

{{{
<regexml xmlns="http://schemas.regexml.org/expressions">
</regexml>
}}}

Other schema-aware XML editors should have similar ways to associate a namespace with a schema file. The structure of the expressions file is discussed in detail in sections below.

== File Format ==



=== Matching Constructs ===

|| *Construct* || *Matches* ||
|| _x_ || Any literal character _x_ except for period, backslash, less than symbol, and double quotes. [`.\<"`] ||
|| `\.` || Period character ||
|| `\\` || Backslash character ||
|| `&lt;` || Less than character (since it conflicts with XML markup) ||
|| `&quot;` || Double quote character `"` (escape not needed when using single-quotes to delimit attribute values) ||
|| `&apos;` || Single quote character `'` (escape not needed when using double-quotes to delimit attribute values) ||
|| `.` || Any character (matches line terminators only if the dotMatchAll attribute is set to true) ||
|| `\d` || Digit [`0-9`] ||
|| `\D` || Non-digit ||
|| `\s` || Whitespace characters including space, tab, new line, form-feed, and carriage return [` \t\n\f\r`] ||
|| `\S` || Non-whitespace character ||
|| `\w` || Word character [`a-zA-Z_0-9`] ||
|| `\W` || Non-word character ||
|| `\b` || Word boundary anchor (e.g., `\bJava\b` matches "Java" but not "JavaScript". Finds whole words only.) ||
|| `\B` || Non-word boundary anchor || 
|| `[ab\d]` || Character class matching a, b, or any digit ||
|| `[0-9a-f]` || Ranges matching digits 0 through 9 and letters a through f (hyphen indicates a range) ||
|| `[a\-c]` || Characters a, c, and hyphen (within character classes, literal hyphens must be escaped) ||

More about constructs here...

= Java API =

Within your application, you can choose to access the regexml expressions file from either the classpath or the file system (depending on whether you choose to pass a `ClassPathResource` or `FileSystemResource` object when instantiating the `ExpressionFactory` class). Keep in mind that after an application is packaged for distribution, it's usually easier to access the expressions file from the classpath rather than the file system.